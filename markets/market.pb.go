// Code generated by protoc-gen-go. DO NOT EDIT.
// source: markets/market.proto

/*
Package ProtobufMarkets is a generated protocol buffer package.

Package ProtobufMarkets contains definitions for market update messages;
the main wrapper messages is a MarketUpdateMessage.

It is generated from these files:
	markets/market.proto
	markets/pair.proto

It has these top-level messages:
	Market
	Order
	Trade
	MarketUpdateMessage
	OrderBookUpdate
	OrderBookDeltaUpdate
	TradesUpdate
	Interval
	IntervalsUpdate
	SummaryUpdate
	SparklineUpdate
	SpreadHistoryUpdate
	PairUpdateMessage
	PairVwapUpdate
	PairPerformanceUpdate
	PairTrendlineUpdate
*/
package ProtobufMarkets

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Market represents a currency pair on a particular exchange.
type Market struct {
	// DEPRECATED
	Exchange     string `protobuf:"bytes,1,opt,name=exchange" json:"exchange,omitempty"`
	CurrencyPair string `protobuf:"bytes,2,opt,name=currencyPair" json:"currencyPair,omitempty"`
	// Prefer integer ids to string slugs (far fewer bytes)
	ExchangeId     uint64 `protobuf:"varint,3,opt,name=exchangeId" json:"exchangeId,omitempty"`
	CurrencyPairId uint64 `protobuf:"varint,4,opt,name=currencyPairId" json:"currencyPairId,omitempty"`
	// New IDs from SQL; TODO remove 1,2,3,4 when migrationt o 5,6 is complete
	MarketId uint64 `protobuf:"varint,5,opt,name=marketId" json:"marketId,omitempty"`
}

func (m *Market) Reset()                    { *m = Market{} }
func (m *Market) String() string            { return proto.CompactTextString(m) }
func (*Market) ProtoMessage()               {}
func (*Market) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Market) GetExchange() string {
	if m != nil {
		return m.Exchange
	}
	return ""
}

func (m *Market) GetCurrencyPair() string {
	if m != nil {
		return m.CurrencyPair
	}
	return ""
}

func (m *Market) GetExchangeId() uint64 {
	if m != nil {
		return m.ExchangeId
	}
	return 0
}

func (m *Market) GetCurrencyPairId() uint64 {
	if m != nil {
		return m.CurrencyPairId
	}
	return 0
}

func (m *Market) GetMarketId() uint64 {
	if m != nil {
		return m.MarketId
	}
	return 0
}

// Order represents an ask or a bid.
type Order struct {
	Price     float32 `protobuf:"fixed32,1,opt,name=price" json:"price,omitempty"`
	Amount    float32 `protobuf:"fixed32,2,opt,name=amount" json:"amount,omitempty"`
	PriceStr  string  `protobuf:"bytes,3,opt,name=priceStr" json:"priceStr,omitempty"`
	AmountStr string  `protobuf:"bytes,4,opt,name=amountStr" json:"amountStr,omitempty"`
}

func (m *Order) Reset()                    { *m = Order{} }
func (m *Order) String() string            { return proto.CompactTextString(m) }
func (*Order) ProtoMessage()               {}
func (*Order) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Order) GetPrice() float32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Order) GetAmount() float32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *Order) GetPriceStr() string {
	if m != nil {
		return m.PriceStr
	}
	return ""
}

func (m *Order) GetAmountStr() string {
	if m != nil {
		return m.AmountStr
	}
	return ""
}

// Trade is a single trade in TradesUpdate
type Trade struct {
	// Exchange-specific ID
	Id              int64   `protobuf:"varint,1,opt,name=id" json:"id,omitempty"`
	Timestamp       int64   `protobuf:"varint,2,opt,name=timestamp" json:"timestamp,omitempty"`
	TimestampMillis int64   `protobuf:"varint,5,opt,name=timestampMillis" json:"timestampMillis,omitempty"`
	Price           float32 `protobuf:"fixed32,3,opt,name=price" json:"price,omitempty"`
	Amount          float32 `protobuf:"fixed32,4,opt,name=amount" json:"amount,omitempty"`
	PriceDouble     float64 `protobuf:"fixed64,6,opt,name=priceDouble" json:"priceDouble,omitempty"`
	AmountDouble    float64 `protobuf:"fixed64,7,opt,name=amountDouble" json:"amountDouble,omitempty"`
	PriceStr        string  `protobuf:"bytes,8,opt,name=priceStr" json:"priceStr,omitempty"`
	AmountStr       string  `protobuf:"bytes,9,opt,name=amountStr" json:"amountStr,omitempty"`
}

func (m *Trade) Reset()                    { *m = Trade{} }
func (m *Trade) String() string            { return proto.CompactTextString(m) }
func (*Trade) ProtoMessage()               {}
func (*Trade) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Trade) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Trade) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Trade) GetTimestampMillis() int64 {
	if m != nil {
		return m.TimestampMillis
	}
	return 0
}

func (m *Trade) GetPrice() float32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Trade) GetAmount() float32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *Trade) GetPriceDouble() float64 {
	if m != nil {
		return m.PriceDouble
	}
	return 0
}

func (m *Trade) GetAmountDouble() float64 {
	if m != nil {
		return m.AmountDouble
	}
	return 0
}

func (m *Trade) GetPriceStr() string {
	if m != nil {
		return m.PriceStr
	}
	return ""
}

func (m *Trade) GetAmountStr() string {
	if m != nil {
		return m.AmountStr
	}
	return ""
}

// MarketUpdateMessage is the primary message for market updates; it wraps all
// other more specific update types.
type MarketUpdateMessage struct {
	Market *Market `protobuf:"bytes,9,opt,name=market" json:"market,omitempty"`
	// Types that are valid to be assigned to Update:
	//	*MarketUpdateMessage_OrderBookUpdate
	//	*MarketUpdateMessage_OrderBookDeltaUpdate
	//	*MarketUpdateMessage_TradesUpdate
	//	*MarketUpdateMessage_IntervalsUpdate
	//	*MarketUpdateMessage_SummaryUpdate
	//	*MarketUpdateMessage_SparklineUpdate
	//	*MarketUpdateMessage_SpreadHistoryUpdate
	Update isMarketUpdateMessage_Update `protobuf_oneof:"Update"`
}

func (m *MarketUpdateMessage) Reset()                    { *m = MarketUpdateMessage{} }
func (m *MarketUpdateMessage) String() string            { return proto.CompactTextString(m) }
func (*MarketUpdateMessage) ProtoMessage()               {}
func (*MarketUpdateMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isMarketUpdateMessage_Update interface {
	isMarketUpdateMessage_Update()
}

type MarketUpdateMessage_OrderBookUpdate struct {
	OrderBookUpdate *OrderBookUpdate `protobuf:"bytes,2,opt,name=orderBookUpdate,oneof"`
}
type MarketUpdateMessage_OrderBookDeltaUpdate struct {
	OrderBookDeltaUpdate *OrderBookDeltaUpdate `protobuf:"bytes,3,opt,name=orderBookDeltaUpdate,oneof"`
}
type MarketUpdateMessage_TradesUpdate struct {
	TradesUpdate *TradesUpdate `protobuf:"bytes,4,opt,name=tradesUpdate,oneof"`
}
type MarketUpdateMessage_IntervalsUpdate struct {
	IntervalsUpdate *IntervalsUpdate `protobuf:"bytes,5,opt,name=intervalsUpdate,oneof"`
}
type MarketUpdateMessage_SummaryUpdate struct {
	SummaryUpdate *SummaryUpdate `protobuf:"bytes,6,opt,name=summaryUpdate,oneof"`
}
type MarketUpdateMessage_SparklineUpdate struct {
	SparklineUpdate *SparklineUpdate `protobuf:"bytes,7,opt,name=sparklineUpdate,oneof"`
}
type MarketUpdateMessage_SpreadHistoryUpdate struct {
	SpreadHistoryUpdate *SpreadHistoryUpdate `protobuf:"bytes,10,opt,name=spreadHistoryUpdate,oneof"`
}

func (*MarketUpdateMessage_OrderBookUpdate) isMarketUpdateMessage_Update()      {}
func (*MarketUpdateMessage_OrderBookDeltaUpdate) isMarketUpdateMessage_Update() {}
func (*MarketUpdateMessage_TradesUpdate) isMarketUpdateMessage_Update()         {}
func (*MarketUpdateMessage_IntervalsUpdate) isMarketUpdateMessage_Update()      {}
func (*MarketUpdateMessage_SummaryUpdate) isMarketUpdateMessage_Update()        {}
func (*MarketUpdateMessage_SparklineUpdate) isMarketUpdateMessage_Update()      {}
func (*MarketUpdateMessage_SpreadHistoryUpdate) isMarketUpdateMessage_Update()  {}

func (m *MarketUpdateMessage) GetUpdate() isMarketUpdateMessage_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *MarketUpdateMessage) GetMarket() *Market {
	if m != nil {
		return m.Market
	}
	return nil
}

func (m *MarketUpdateMessage) GetOrderBookUpdate() *OrderBookUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_OrderBookUpdate); ok {
		return x.OrderBookUpdate
	}
	return nil
}

func (m *MarketUpdateMessage) GetOrderBookDeltaUpdate() *OrderBookDeltaUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_OrderBookDeltaUpdate); ok {
		return x.OrderBookDeltaUpdate
	}
	return nil
}

func (m *MarketUpdateMessage) GetTradesUpdate() *TradesUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_TradesUpdate); ok {
		return x.TradesUpdate
	}
	return nil
}

func (m *MarketUpdateMessage) GetIntervalsUpdate() *IntervalsUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_IntervalsUpdate); ok {
		return x.IntervalsUpdate
	}
	return nil
}

func (m *MarketUpdateMessage) GetSummaryUpdate() *SummaryUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_SummaryUpdate); ok {
		return x.SummaryUpdate
	}
	return nil
}

func (m *MarketUpdateMessage) GetSparklineUpdate() *SparklineUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_SparklineUpdate); ok {
		return x.SparklineUpdate
	}
	return nil
}

func (m *MarketUpdateMessage) GetSpreadHistoryUpdate() *SpreadHistoryUpdate {
	if x, ok := m.GetUpdate().(*MarketUpdateMessage_SpreadHistoryUpdate); ok {
		return x.SpreadHistoryUpdate
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*MarketUpdateMessage) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _MarketUpdateMessage_OneofMarshaler, _MarketUpdateMessage_OneofUnmarshaler, _MarketUpdateMessage_OneofSizer, []interface{}{
		(*MarketUpdateMessage_OrderBookUpdate)(nil),
		(*MarketUpdateMessage_OrderBookDeltaUpdate)(nil),
		(*MarketUpdateMessage_TradesUpdate)(nil),
		(*MarketUpdateMessage_IntervalsUpdate)(nil),
		(*MarketUpdateMessage_SummaryUpdate)(nil),
		(*MarketUpdateMessage_SparklineUpdate)(nil),
		(*MarketUpdateMessage_SpreadHistoryUpdate)(nil),
	}
}

func _MarketUpdateMessage_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*MarketUpdateMessage)
	// Update
	switch x := m.Update.(type) {
	case *MarketUpdateMessage_OrderBookUpdate:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OrderBookUpdate); err != nil {
			return err
		}
	case *MarketUpdateMessage_OrderBookDeltaUpdate:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OrderBookDeltaUpdate); err != nil {
			return err
		}
	case *MarketUpdateMessage_TradesUpdate:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TradesUpdate); err != nil {
			return err
		}
	case *MarketUpdateMessage_IntervalsUpdate:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.IntervalsUpdate); err != nil {
			return err
		}
	case *MarketUpdateMessage_SummaryUpdate:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SummaryUpdate); err != nil {
			return err
		}
	case *MarketUpdateMessage_SparklineUpdate:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SparklineUpdate); err != nil {
			return err
		}
	case *MarketUpdateMessage_SpreadHistoryUpdate:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.SpreadHistoryUpdate); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("MarketUpdateMessage.Update has unexpected type %T", x)
	}
	return nil
}

func _MarketUpdateMessage_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*MarketUpdateMessage)
	switch tag {
	case 2: // Update.orderBookUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OrderBookUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_OrderBookUpdate{msg}
		return true, err
	case 3: // Update.orderBookDeltaUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OrderBookDeltaUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_OrderBookDeltaUpdate{msg}
		return true, err
	case 4: // Update.tradesUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TradesUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_TradesUpdate{msg}
		return true, err
	case 5: // Update.intervalsUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(IntervalsUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_IntervalsUpdate{msg}
		return true, err
	case 6: // Update.summaryUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SummaryUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_SummaryUpdate{msg}
		return true, err
	case 7: // Update.sparklineUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SparklineUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_SparklineUpdate{msg}
		return true, err
	case 10: // Update.spreadHistoryUpdate
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(SpreadHistoryUpdate)
		err := b.DecodeMessage(msg)
		m.Update = &MarketUpdateMessage_SpreadHistoryUpdate{msg}
		return true, err
	default:
		return false, nil
	}
}

func _MarketUpdateMessage_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*MarketUpdateMessage)
	// Update
	switch x := m.Update.(type) {
	case *MarketUpdateMessage_OrderBookUpdate:
		s := proto.Size(x.OrderBookUpdate)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MarketUpdateMessage_OrderBookDeltaUpdate:
		s := proto.Size(x.OrderBookDeltaUpdate)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MarketUpdateMessage_TradesUpdate:
		s := proto.Size(x.TradesUpdate)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MarketUpdateMessage_IntervalsUpdate:
		s := proto.Size(x.IntervalsUpdate)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MarketUpdateMessage_SummaryUpdate:
		s := proto.Size(x.SummaryUpdate)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MarketUpdateMessage_SparklineUpdate:
		s := proto.Size(x.SparklineUpdate)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *MarketUpdateMessage_SpreadHistoryUpdate:
		s := proto.Size(x.SpreadHistoryUpdate)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// OrderBookUpdate represents a snapshot of the order book: a set of asks and
// bids for the particular aggregation modulus.
type OrderBookUpdate struct {
	// Aggregation modulus is a value which all bids and asks in this particular
	// OrderBookUpdate are divisible by. E.g. could be 1 (no aggregation), 5, 10,
	// 50, 100, etc. Exact possible values are set for each market individually.
	AggregationModulus    float32  `protobuf:"fixed32,3,opt,name=aggregationModulus" json:"aggregationModulus,omitempty"`
	AggregationModulusStr string   `protobuf:"bytes,4,opt,name=aggregationModulusStr" json:"aggregationModulusStr,omitempty"`
	SeqNum                int32    `protobuf:"varint,5,opt,name=seqNum" json:"seqNum,omitempty"`
	Bids                  []*Order `protobuf:"bytes,1,rep,name=bids" json:"bids,omitempty"`
	Asks                  []*Order `protobuf:"bytes,2,rep,name=asks" json:"asks,omitempty"`
}

func (m *OrderBookUpdate) Reset()                    { *m = OrderBookUpdate{} }
func (m *OrderBookUpdate) String() string            { return proto.CompactTextString(m) }
func (*OrderBookUpdate) ProtoMessage()               {}
func (*OrderBookUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *OrderBookUpdate) GetAggregationModulus() float32 {
	if m != nil {
		return m.AggregationModulus
	}
	return 0
}

func (m *OrderBookUpdate) GetAggregationModulusStr() string {
	if m != nil {
		return m.AggregationModulusStr
	}
	return ""
}

func (m *OrderBookUpdate) GetSeqNum() int32 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *OrderBookUpdate) GetBids() []*Order {
	if m != nil {
		return m.Bids
	}
	return nil
}

func (m *OrderBookUpdate) GetAsks() []*Order {
	if m != nil {
		return m.Asks
	}
	return nil
}

// OrderBookDeltaUpdate represents a delta which needs to be applied to the
// local order book.
type OrderBookDeltaUpdate struct {
	// Aggregation modulus is a value which all bids and asks in this particular
	// OrderBookUpdate are divisible by. E.g. could be 1 (no aggregation), 5, 10,
	// 50, 100, etc. Exact possible values are set for each market individually.
	AggregationModulus    float32 `protobuf:"fixed32,3,opt,name=aggregationModulus" json:"aggregationModulus,omitempty"`
	AggregationModulusStr string  `protobuf:"bytes,4,opt,name=aggregationModulusStr" json:"aggregationModulusStr,omitempty"`
	SeqNum                int32   `protobuf:"varint,5,opt,name=seqNum" json:"seqNum,omitempty"`
	// Deltas for bids
	Bids *OrderBookDeltaUpdate_OrderDeltas `protobuf:"bytes,1,opt,name=bids" json:"bids,omitempty"`
	// Deltas for asks
	Asks *OrderBookDeltaUpdate_OrderDeltas `protobuf:"bytes,2,opt,name=asks" json:"asks,omitempty"`
}

func (m *OrderBookDeltaUpdate) Reset()                    { *m = OrderBookDeltaUpdate{} }
func (m *OrderBookDeltaUpdate) String() string            { return proto.CompactTextString(m) }
func (*OrderBookDeltaUpdate) ProtoMessage()               {}
func (*OrderBookDeltaUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *OrderBookDeltaUpdate) GetAggregationModulus() float32 {
	if m != nil {
		return m.AggregationModulus
	}
	return 0
}

func (m *OrderBookDeltaUpdate) GetAggregationModulusStr() string {
	if m != nil {
		return m.AggregationModulusStr
	}
	return ""
}

func (m *OrderBookDeltaUpdate) GetSeqNum() int32 {
	if m != nil {
		return m.SeqNum
	}
	return 0
}

func (m *OrderBookDeltaUpdate) GetBids() *OrderBookDeltaUpdate_OrderDeltas {
	if m != nil {
		return m.Bids
	}
	return nil
}

func (m *OrderBookDeltaUpdate) GetAsks() *OrderBookDeltaUpdate_OrderDeltas {
	if m != nil {
		return m.Asks
	}
	return nil
}

type OrderBookDeltaUpdate_OrderDeltas struct {
	// Either add a new order at a particular price, or replace existing one
	// (with the new amount)
	Set []*Order `protobuf:"bytes,1,rep,name=set" json:"set,omitempty"`
	// TODO: I see we don't really use deltas, and just use set?
	Delta []*Order `protobuf:"bytes,2,rep,name=delta" json:"delta,omitempty"`
	// Remove order at a particular price
	Remove    []float32 `protobuf:"fixed32,3,rep,name=remove" json:"remove,omitempty"`
	RemoveStr []string  `protobuf:"bytes,4,rep,name=removeStr" json:"removeStr,omitempty"`
}

func (m *OrderBookDeltaUpdate_OrderDeltas) Reset()         { *m = OrderBookDeltaUpdate_OrderDeltas{} }
func (m *OrderBookDeltaUpdate_OrderDeltas) String() string { return proto.CompactTextString(m) }
func (*OrderBookDeltaUpdate_OrderDeltas) ProtoMessage()    {}
func (*OrderBookDeltaUpdate_OrderDeltas) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{5, 0}
}

func (m *OrderBookDeltaUpdate_OrderDeltas) GetSet() []*Order {
	if m != nil {
		return m.Set
	}
	return nil
}

func (m *OrderBookDeltaUpdate_OrderDeltas) GetDelta() []*Order {
	if m != nil {
		return m.Delta
	}
	return nil
}

func (m *OrderBookDeltaUpdate_OrderDeltas) GetRemove() []float32 {
	if m != nil {
		return m.Remove
	}
	return nil
}

func (m *OrderBookDeltaUpdate_OrderDeltas) GetRemoveStr() []string {
	if m != nil {
		return m.RemoveStr
	}
	return nil
}

// TradesUpdate represents a set of new trades.
type TradesUpdate struct {
	Trades []*Trade `protobuf:"bytes,1,rep,name=trades" json:"trades,omitempty"`
}

func (m *TradesUpdate) Reset()                    { *m = TradesUpdate{} }
func (m *TradesUpdate) String() string            { return proto.CompactTextString(m) }
func (*TradesUpdate) ProtoMessage()               {}
func (*TradesUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *TradesUpdate) GetTrades() []*Trade {
	if m != nil {
		return m.Trades
	}
	return nil
}

// Interval represents a single OHLC candle.
type Interval struct {
	Closetime      int64          `protobuf:"varint,1,opt,name=closetime" json:"closetime,omitempty"`
	Period         int32          `protobuf:"varint,4,opt,name=period" json:"period,omitempty"`
	Ohlc           *Interval_OHLC `protobuf:"bytes,2,opt,name=ohlc" json:"ohlc,omitempty"`
	VolumeBase     float32        `protobuf:"fixed32,3,opt,name=volumeBase" json:"volumeBase,omitempty"`
	VolumeQuote    float32        `protobuf:"fixed32,5,opt,name=volumeQuote" json:"volumeQuote,omitempty"`
	VolumeBaseStr  string         `protobuf:"bytes,6,opt,name=volumeBaseStr" json:"volumeBaseStr,omitempty"`
	VolumeQuoteStr string         `protobuf:"bytes,7,opt,name=volumeQuoteStr" json:"volumeQuoteStr,omitempty"`
}

func (m *Interval) Reset()                    { *m = Interval{} }
func (m *Interval) String() string            { return proto.CompactTextString(m) }
func (*Interval) ProtoMessage()               {}
func (*Interval) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Interval) GetClosetime() int64 {
	if m != nil {
		return m.Closetime
	}
	return 0
}

func (m *Interval) GetPeriod() int32 {
	if m != nil {
		return m.Period
	}
	return 0
}

func (m *Interval) GetOhlc() *Interval_OHLC {
	if m != nil {
		return m.Ohlc
	}
	return nil
}

func (m *Interval) GetVolumeBase() float32 {
	if m != nil {
		return m.VolumeBase
	}
	return 0
}

func (m *Interval) GetVolumeQuote() float32 {
	if m != nil {
		return m.VolumeQuote
	}
	return 0
}

func (m *Interval) GetVolumeBaseStr() string {
	if m != nil {
		return m.VolumeBaseStr
	}
	return ""
}

func (m *Interval) GetVolumeQuoteStr() string {
	if m != nil {
		return m.VolumeQuoteStr
	}
	return ""
}

type Interval_OHLC struct {
	Open     float32 `protobuf:"fixed32,1,opt,name=open" json:"open,omitempty"`
	High     float32 `protobuf:"fixed32,2,opt,name=high" json:"high,omitempty"`
	Low      float32 `protobuf:"fixed32,3,opt,name=low" json:"low,omitempty"`
	Close    float32 `protobuf:"fixed32,4,opt,name=close" json:"close,omitempty"`
	OpenStr  string  `protobuf:"bytes,5,opt,name=openStr" json:"openStr,omitempty"`
	HighStr  string  `protobuf:"bytes,6,opt,name=highStr" json:"highStr,omitempty"`
	LowStr   string  `protobuf:"bytes,7,opt,name=lowStr" json:"lowStr,omitempty"`
	CloseStr string  `protobuf:"bytes,8,opt,name=closeStr" json:"closeStr,omitempty"`
}

func (m *Interval_OHLC) Reset()                    { *m = Interval_OHLC{} }
func (m *Interval_OHLC) String() string            { return proto.CompactTextString(m) }
func (*Interval_OHLC) ProtoMessage()               {}
func (*Interval_OHLC) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

func (m *Interval_OHLC) GetOpen() float32 {
	if m != nil {
		return m.Open
	}
	return 0
}

func (m *Interval_OHLC) GetHigh() float32 {
	if m != nil {
		return m.High
	}
	return 0
}

func (m *Interval_OHLC) GetLow() float32 {
	if m != nil {
		return m.Low
	}
	return 0
}

func (m *Interval_OHLC) GetClose() float32 {
	if m != nil {
		return m.Close
	}
	return 0
}

func (m *Interval_OHLC) GetOpenStr() string {
	if m != nil {
		return m.OpenStr
	}
	return ""
}

func (m *Interval_OHLC) GetHighStr() string {
	if m != nil {
		return m.HighStr
	}
	return ""
}

func (m *Interval_OHLC) GetLowStr() string {
	if m != nil {
		return m.LowStr
	}
	return ""
}

func (m *Interval_OHLC) GetCloseStr() string {
	if m != nil {
		return m.CloseStr
	}
	return ""
}

// IntervalsUpdate represents a set of new Intervals (OHLC candles)
type IntervalsUpdate struct {
	Intervals []*Interval `protobuf:"bytes,1,rep,name=intervals" json:"intervals,omitempty"`
}

func (m *IntervalsUpdate) Reset()                    { *m = IntervalsUpdate{} }
func (m *IntervalsUpdate) String() string            { return proto.CompactTextString(m) }
func (*IntervalsUpdate) ProtoMessage()               {}
func (*IntervalsUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *IntervalsUpdate) GetIntervals() []*Interval {
	if m != nil {
		return m.Intervals
	}
	return nil
}

// SummaryUpdate is a market summary update
type SummaryUpdate struct {
	Last              float32 `protobuf:"fixed32,2,opt,name=last" json:"last,omitempty"`
	High              float32 `protobuf:"fixed32,3,opt,name=high" json:"high,omitempty"`
	Low               float32 `protobuf:"fixed32,4,opt,name=low" json:"low,omitempty"`
	VolumeBase        float32 `protobuf:"fixed32,5,opt,name=volumeBase" json:"volumeBase,omitempty"`
	VolumeQuote       float32 `protobuf:"fixed32,9,opt,name=volumeQuote" json:"volumeQuote,omitempty"`
	ChangeAbsolute    float32 `protobuf:"fixed32,6,opt,name=changeAbsolute" json:"changeAbsolute,omitempty"`
	ChangePercent     float32 `protobuf:"fixed32,7,opt,name=changePercent" json:"changePercent,omitempty"`
	LastStr           string  `protobuf:"bytes,10,opt,name=lastStr" json:"lastStr,omitempty"`
	HighStr           string  `protobuf:"bytes,11,opt,name=highStr" json:"highStr,omitempty"`
	LowStr            string  `protobuf:"bytes,12,opt,name=lowStr" json:"lowStr,omitempty"`
	VolumeBaseStr     string  `protobuf:"bytes,13,opt,name=volumeBaseStr" json:"volumeBaseStr,omitempty"`
	VolumeQuoteStr    string  `protobuf:"bytes,14,opt,name=volumeQuoteStr" json:"volumeQuoteStr,omitempty"`
	ChangeAbsoluteStr string  `protobuf:"bytes,15,opt,name=changeAbsoluteStr" json:"changeAbsoluteStr,omitempty"`
	ChangePercentStr  string  `protobuf:"bytes,16,opt,name=changePercentStr" json:"changePercentStr,omitempty"`
	NumTrades         int32   `protobuf:"varint,8,opt,name=numTrades" json:"numTrades,omitempty"`
}

func (m *SummaryUpdate) Reset()                    { *m = SummaryUpdate{} }
func (m *SummaryUpdate) String() string            { return proto.CompactTextString(m) }
func (*SummaryUpdate) ProtoMessage()               {}
func (*SummaryUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *SummaryUpdate) GetLast() float32 {
	if m != nil {
		return m.Last
	}
	return 0
}

func (m *SummaryUpdate) GetHigh() float32 {
	if m != nil {
		return m.High
	}
	return 0
}

func (m *SummaryUpdate) GetLow() float32 {
	if m != nil {
		return m.Low
	}
	return 0
}

func (m *SummaryUpdate) GetVolumeBase() float32 {
	if m != nil {
		return m.VolumeBase
	}
	return 0
}

func (m *SummaryUpdate) GetVolumeQuote() float32 {
	if m != nil {
		return m.VolumeQuote
	}
	return 0
}

func (m *SummaryUpdate) GetChangeAbsolute() float32 {
	if m != nil {
		return m.ChangeAbsolute
	}
	return 0
}

func (m *SummaryUpdate) GetChangePercent() float32 {
	if m != nil {
		return m.ChangePercent
	}
	return 0
}

func (m *SummaryUpdate) GetLastStr() string {
	if m != nil {
		return m.LastStr
	}
	return ""
}

func (m *SummaryUpdate) GetHighStr() string {
	if m != nil {
		return m.HighStr
	}
	return ""
}

func (m *SummaryUpdate) GetLowStr() string {
	if m != nil {
		return m.LowStr
	}
	return ""
}

func (m *SummaryUpdate) GetVolumeBaseStr() string {
	if m != nil {
		return m.VolumeBaseStr
	}
	return ""
}

func (m *SummaryUpdate) GetVolumeQuoteStr() string {
	if m != nil {
		return m.VolumeQuoteStr
	}
	return ""
}

func (m *SummaryUpdate) GetChangeAbsoluteStr() string {
	if m != nil {
		return m.ChangeAbsoluteStr
	}
	return ""
}

func (m *SummaryUpdate) GetChangePercentStr() string {
	if m != nil {
		return m.ChangePercentStr
	}
	return ""
}

func (m *SummaryUpdate) GetNumTrades() int32 {
	if m != nil {
		return m.NumTrades
	}
	return 0
}

type SparklineUpdate struct {
	Time     int64   `protobuf:"varint,2,opt,name=time" json:"time,omitempty"`
	Price    float32 `protobuf:"fixed32,3,opt,name=price" json:"price,omitempty"`
	PriceStr string  `protobuf:"bytes,4,opt,name=priceStr" json:"priceStr,omitempty"`
}

func (m *SparklineUpdate) Reset()                    { *m = SparklineUpdate{} }
func (m *SparklineUpdate) String() string            { return proto.CompactTextString(m) }
func (*SparklineUpdate) ProtoMessage()               {}
func (*SparklineUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *SparklineUpdate) GetTime() int64 {
	if m != nil {
		return m.Time
	}
	return 0
}

func (m *SparklineUpdate) GetPrice() float32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *SparklineUpdate) GetPriceStr() string {
	if m != nil {
		return m.PriceStr
	}
	return ""
}

type SpreadHistoryUpdate struct {
	Asks      []*SpreadHistoryUpdate_SpreadHistoryPoint `protobuf:"bytes,1,rep,name=asks" json:"asks,omitempty"`
	Bids      []*SpreadHistoryUpdate_SpreadHistoryPoint `protobuf:"bytes,2,rep,name=bids" json:"bids,omitempty"`
	Timestamp int64                                     `protobuf:"varint,3,opt,name=timestamp" json:"timestamp,omitempty"`
	Bid       *Order                                    `protobuf:"bytes,4,opt,name=bid" json:"bid,omitempty"`
	Ask       *Order                                    `protobuf:"bytes,5,opt,name=ask" json:"ask,omitempty"`
}

func (m *SpreadHistoryUpdate) Reset()                    { *m = SpreadHistoryUpdate{} }
func (m *SpreadHistoryUpdate) String() string            { return proto.CompactTextString(m) }
func (*SpreadHistoryUpdate) ProtoMessage()               {}
func (*SpreadHistoryUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *SpreadHistoryUpdate) GetAsks() []*SpreadHistoryUpdate_SpreadHistoryPoint {
	if m != nil {
		return m.Asks
	}
	return nil
}

func (m *SpreadHistoryUpdate) GetBids() []*SpreadHistoryUpdate_SpreadHistoryPoint {
	if m != nil {
		return m.Bids
	}
	return nil
}

func (m *SpreadHistoryUpdate) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *SpreadHistoryUpdate) GetBid() *Order {
	if m != nil {
		return m.Bid
	}
	return nil
}

func (m *SpreadHistoryUpdate) GetAsk() *Order {
	if m != nil {
		return m.Ask
	}
	return nil
}

type SpreadHistoryUpdate_SpreadHistoryPoint struct {
	Timestamp int64   `protobuf:"varint,1,opt,name=timestamp" json:"timestamp,omitempty"`
	Price     float32 `protobuf:"fixed32,2,opt,name=price" json:"price,omitempty"`
	Amount    float32 `protobuf:"fixed32,3,opt,name=amount" json:"amount,omitempty"`
	PriceStr  string  `protobuf:"bytes,4,opt,name=priceStr" json:"priceStr,omitempty"`
	AmountStr string  `protobuf:"bytes,5,opt,name=amountStr" json:"amountStr,omitempty"`
}

func (m *SpreadHistoryUpdate_SpreadHistoryPoint) Reset() {
	*m = SpreadHistoryUpdate_SpreadHistoryPoint{}
}
func (m *SpreadHistoryUpdate_SpreadHistoryPoint) String() string { return proto.CompactTextString(m) }
func (*SpreadHistoryUpdate_SpreadHistoryPoint) ProtoMessage()    {}
func (*SpreadHistoryUpdate_SpreadHistoryPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{11, 0}
}

func (m *SpreadHistoryUpdate_SpreadHistoryPoint) GetTimestamp() int64 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *SpreadHistoryUpdate_SpreadHistoryPoint) GetPrice() float32 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *SpreadHistoryUpdate_SpreadHistoryPoint) GetAmount() float32 {
	if m != nil {
		return m.Amount
	}
	return 0
}

func (m *SpreadHistoryUpdate_SpreadHistoryPoint) GetPriceStr() string {
	if m != nil {
		return m.PriceStr
	}
	return ""
}

func (m *SpreadHistoryUpdate_SpreadHistoryPoint) GetAmountStr() string {
	if m != nil {
		return m.AmountStr
	}
	return ""
}

func init() {
	proto.RegisterType((*Market)(nil), "ProtobufMarkets.Market")
	proto.RegisterType((*Order)(nil), "ProtobufMarkets.Order")
	proto.RegisterType((*Trade)(nil), "ProtobufMarkets.Trade")
	proto.RegisterType((*MarketUpdateMessage)(nil), "ProtobufMarkets.MarketUpdateMessage")
	proto.RegisterType((*OrderBookUpdate)(nil), "ProtobufMarkets.OrderBookUpdate")
	proto.RegisterType((*OrderBookDeltaUpdate)(nil), "ProtobufMarkets.OrderBookDeltaUpdate")
	proto.RegisterType((*OrderBookDeltaUpdate_OrderDeltas)(nil), "ProtobufMarkets.OrderBookDeltaUpdate.OrderDeltas")
	proto.RegisterType((*TradesUpdate)(nil), "ProtobufMarkets.TradesUpdate")
	proto.RegisterType((*Interval)(nil), "ProtobufMarkets.Interval")
	proto.RegisterType((*Interval_OHLC)(nil), "ProtobufMarkets.Interval.OHLC")
	proto.RegisterType((*IntervalsUpdate)(nil), "ProtobufMarkets.IntervalsUpdate")
	proto.RegisterType((*SummaryUpdate)(nil), "ProtobufMarkets.SummaryUpdate")
	proto.RegisterType((*SparklineUpdate)(nil), "ProtobufMarkets.SparklineUpdate")
	proto.RegisterType((*SpreadHistoryUpdate)(nil), "ProtobufMarkets.SpreadHistoryUpdate")
	proto.RegisterType((*SpreadHistoryUpdate_SpreadHistoryPoint)(nil), "ProtobufMarkets.SpreadHistoryUpdate.SpreadHistoryPoint")
}

func init() { proto.RegisterFile("markets/market.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1156 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0xcd, 0x6e, 0x23, 0xc5,
	0x13, 0xf7, 0x7c, 0x39, 0x76, 0x39, 0x59, 0xfb, 0xdf, 0x9b, 0xff, 0x62, 0x22, 0x88, 0xac, 0xd1,
	0x82, 0xac, 0xd5, 0xca, 0x2b, 0x02, 0xd2, 0xde, 0x90, 0xc8, 0xee, 0x22, 0x27, 0x6c, 0x48, 0xe8,
	0x2c, 0x12, 0x12, 0xe2, 0x30, 0xf6, 0x34, 0xce, 0xc8, 0x63, 0xb7, 0x99, 0x9e, 0xc9, 0xb2, 0x77,
	0xae, 0xbc, 0x00, 0x17, 0x5e, 0x80, 0x67, 0xd8, 0x13, 0x3c, 0x0b, 0x67, 0xde, 0x00, 0x55, 0x77,
	0x7b, 0xbe, 0x27, 0x89, 0xe0, 0xc0, 0xc9, 0x5d, 0xbf, 0xfe, 0x75, 0x75, 0x75, 0x55, 0x4d, 0x55,
	0x19, 0xf6, 0x57, 0x5e, 0xb4, 0x64, 0xb1, 0x78, 0xa2, 0x7e, 0x27, 0x9b, 0x88, 0xc7, 0x9c, 0xf4,
	0x2f, 0xf0, 0x67, 0x96, 0x7c, 0x7f, 0xa6, 0x76, 0xdd, 0xdf, 0x0c, 0x68, 0xab, 0x35, 0x39, 0x80,
	0x0e, 0xfb, 0x71, 0x7e, 0xe5, 0xad, 0x17, 0x6c, 0x68, 0x8c, 0x8c, 0x71, 0x97, 0xa6, 0x32, 0x71,
	0x61, 0x77, 0x9e, 0x44, 0x11, 0x5b, 0xcf, 0xdf, 0x5c, 0x78, 0x41, 0x34, 0x34, 0xe5, 0x7e, 0x01,
	0x23, 0x87, 0x00, 0x5b, 0xfe, 0x89, 0x3f, 0xb4, 0x46, 0xc6, 0xd8, 0xa6, 0x39, 0x84, 0x7c, 0x08,
	0xf7, 0xf2, 0xfc, 0x13, 0x7f, 0x68, 0x4b, 0x4e, 0x09, 0x45, 0x3b, 0x94, 0xcd, 0x27, 0xfe, 0xd0,
	0x91, 0x8c, 0x54, 0x76, 0x39, 0x38, 0xe7, 0x91, 0xcf, 0x22, 0xb2, 0x0f, 0xce, 0x26, 0x0a, 0xe6,
	0xca, 0x52, 0x93, 0x2a, 0x81, 0x3c, 0x80, 0xb6, 0xb7, 0xe2, 0xc9, 0x3a, 0x96, 0x06, 0x9a, 0x54,
	0x4b, 0xa8, 0x52, 0x12, 0x2e, 0xe3, 0x48, 0x1a, 0xd6, 0xa5, 0xa9, 0x4c, 0xde, 0x83, 0xae, 0x62,
	0xe1, 0xa6, 0x2d, 0x37, 0x33, 0xc0, 0xfd, 0xd9, 0x04, 0xe7, 0x55, 0xe4, 0xf9, 0x8c, 0xdc, 0x03,
	0x33, 0xf0, 0xe5, 0x75, 0x16, 0x35, 0x03, 0x1f, 0xcf, 0xc5, 0xc1, 0x8a, 0x89, 0xd8, 0x5b, 0x6d,
	0xe4, 0x75, 0x16, 0xcd, 0x00, 0x32, 0x86, 0x7e, 0x2a, 0x9c, 0x05, 0x61, 0x18, 0x08, 0xf9, 0x16,
	0x8b, 0x96, 0xe1, 0xec, 0x25, 0x56, 0xfd, 0x4b, 0xec, 0xc2, 0x4b, 0x46, 0xd0, 0x93, 0x84, 0xe7,
	0x3c, 0x99, 0x85, 0x6c, 0xd8, 0x1e, 0x19, 0x63, 0x83, 0xe6, 0x21, 0x0c, 0x95, 0xe2, 0x6a, 0xca,
	0x8e, 0xa4, 0x14, 0xb0, 0x82, 0x3f, 0x3a, 0x37, 0xf9, 0xa3, 0x5b, 0xf6, 0xc7, 0x4f, 0x0e, 0xdc,
	0x57, 0xf9, 0xf2, 0xf5, 0xc6, 0xf7, 0x62, 0x76, 0xc6, 0x84, 0xf0, 0x16, 0x8c, 0x3c, 0x81, 0xb6,
	0x0a, 0x92, 0x3c, 0xd2, 0x3b, 0x7a, 0x67, 0x52, 0xca, 0xb4, 0x89, 0xfa, 0xa5, 0x9a, 0x46, 0x5e,
	0x42, 0x9f, 0x63, 0x24, 0x8f, 0x39, 0x5f, 0x2a, 0x55, 0xd2, 0x89, 0xbd, 0xa3, 0x51, 0xe5, 0xe4,
	0x79, 0x91, 0x37, 0x6d, 0xd1, 0xf2, 0x51, 0xf2, 0x2d, 0xec, 0xa7, 0xd0, 0x73, 0x16, 0xc6, 0x9e,
	0x56, 0x69, 0x49, 0x95, 0x1f, 0x34, 0xab, 0xcc, 0x91, 0xa7, 0x2d, 0x5a, 0xab, 0x84, 0x3c, 0x83,
	0xdd, 0x18, 0x53, 0x40, 0x68, 0xa5, 0xb6, 0x54, 0xfa, 0x7e, 0x45, 0xe9, 0xab, 0x1c, 0x69, 0xda,
	0xa2, 0x85, 0x43, 0xf8, 0xde, 0x60, 0x1d, 0xb3, 0xe8, 0xda, 0x0b, 0xb7, 0x7a, 0x9c, 0x86, 0xf7,
	0x9e, 0x14, 0x79, 0xf8, 0xde, 0xd2, 0x51, 0xf2, 0x39, 0xec, 0x89, 0x64, 0xb5, 0xf2, 0xa2, 0x37,
	0x5a, 0x57, 0x5b, 0xea, 0x3a, 0xac, 0xe8, 0xba, 0xcc, 0xb3, 0xa6, 0x2d, 0x5a, 0x3c, 0x86, 0x56,
	0x89, 0x8d, 0x17, 0x2d, 0xc3, 0x60, 0xcd, 0xb4, 0xa6, 0x9d, 0x06, 0xab, 0x2e, 0x8b, 0x3c, 0xb4,
	0xaa, 0x74, 0x94, 0x7c, 0x03, 0xf7, 0xc5, 0x26, 0x62, 0x9e, 0x3f, 0x0d, 0x44, 0xcc, 0x53, 0xdb,
	0x40, 0x6a, 0x7c, 0x58, 0xa3, 0xb1, 0xc2, 0x9d, 0xb6, 0x68, 0x9d, 0x8a, 0xe3, 0x0e, 0xb4, 0xd5,
	0xea, 0xd4, 0xee, 0x74, 0x06, 0x5d, 0xf7, 0x4f, 0x03, 0xfa, 0xa5, 0xb4, 0x20, 0x13, 0x20, 0xde,
	0x62, 0x11, 0xb1, 0x85, 0x17, 0x07, 0x7c, 0x7d, 0xc6, 0xfd, 0x24, 0x4c, 0x84, 0xfe, 0xaa, 0x6a,
	0x76, 0xc8, 0x27, 0xf0, 0xff, 0x2a, 0x9a, 0x15, 0x81, 0xfa, 0x4d, 0xfc, 0x30, 0x05, 0xfb, 0xe1,
	0xcb, 0x64, 0x25, 0xc3, 0xe7, 0x50, 0x2d, 0x91, 0x47, 0x60, 0xcf, 0x02, 0x5f, 0x0c, 0x8d, 0x91,
	0x35, 0xee, 0x1d, 0x3d, 0xa8, 0xcf, 0x38, 0x2a, 0x39, 0xc8, 0xf5, 0xc4, 0x52, 0x0c, 0xcd, 0x9b,
	0xb9, 0xc8, 0x71, 0x7f, 0xb7, 0x60, 0xbf, 0x2e, 0x5b, 0xff, 0xe3, 0xe7, 0xbe, 0x48, 0x9f, 0x8b,
	0xb1, 0xfd, 0xe8, 0x4e, 0x1f, 0x98, 0x02, 0x25, 0x20, 0xb4, 0x27, 0x5e, 0xa4, 0x9e, 0xf8, 0xa7,
	0x6a, 0xf0, 0xf8, 0xc1, 0xaf, 0x06, 0xf4, 0x72, 0x28, 0x19, 0x83, 0x25, 0x58, 0x7c, 0x4b, 0x2c,
	0x90, 0x42, 0x1e, 0x83, 0xe3, 0xe3, 0x99, 0x5b, 0x62, 0xa1, 0x48, 0xe4, 0x00, 0xda, 0x11, 0x5b,
	0xf1, 0x6b, 0x2c, 0x2c, 0xd6, 0xd8, 0x3c, 0x36, 0x07, 0x2d, 0xaa, 0x11, 0xac, 0x9b, 0x6a, 0xa5,
	0x7c, 0x6a, 0x61, 0xdd, 0x4c, 0x01, 0xf7, 0x53, 0xd8, 0xcd, 0x97, 0x07, 0x32, 0x81, 0xb6, 0x2a,
	0x0f, 0x8d, 0x46, 0x4a, 0x3a, 0xd5, 0x2c, 0xf7, 0x0f, 0x0b, 0x3a, 0xdb, 0xba, 0x80, 0x57, 0xcd,
	0x43, 0x2e, 0x18, 0xb6, 0x12, 0xdd, 0x91, 0x32, 0x00, 0x43, 0xb6, 0x61, 0x51, 0xc0, 0x55, 0x7f,
	0x75, 0xa8, 0x96, 0xc8, 0x11, 0xd8, 0xfc, 0x2a, 0x9c, 0x6b, 0x5f, 0x1f, 0x36, 0x96, 0x9d, 0xc9,
	0xf9, 0xf4, 0xe5, 0x33, 0x2a, 0xb9, 0xd8, 0xd3, 0xaf, 0x79, 0x98, 0xac, 0xd8, 0xb1, 0x27, 0xb6,
	0x1d, 0x2a, 0x87, 0x60, 0x3b, 0x52, 0xd2, 0x57, 0x09, 0xd7, 0x15, 0xcd, 0xa4, 0x79, 0x88, 0x3c,
	0x84, 0xbd, 0x8c, 0x8f, 0xae, 0x69, 0xcb, 0x74, 0x2b, 0x82, 0x38, 0x1b, 0xe4, 0x0e, 0x21, 0x6d,
	0x47, 0xd2, 0x4a, 0xe8, 0xc1, 0x5b, 0x03, 0x6c, 0x34, 0x8f, 0x10, 0xb0, 0xf9, 0x86, 0xad, 0x75,
	0xfb, 0x97, 0x6b, 0xc4, 0xae, 0x82, 0xc5, 0x95, 0xee, 0xfd, 0x72, 0x4d, 0x06, 0x60, 0x85, 0xfc,
	0xb5, 0xb6, 0x1c, 0x97, 0xd8, 0x6f, 0xa5, 0xaf, 0x74, 0x63, 0x55, 0x02, 0x19, 0xc2, 0x0e, 0xea,
	0xc0, 0x9b, 0x1d, 0x79, 0xf3, 0x56, 0xc4, 0x1d, 0xd4, 0x94, 0x99, 0xbe, 0x15, 0xd1, 0xd1, 0x21,
	0x7f, 0x9d, 0x19, 0xab, 0x25, 0xec, 0xae, 0x52, 0x69, 0xae, 0xbb, 0x6e, 0x65, 0xf7, 0x14, 0xfa,
	0xa5, 0xf2, 0x4e, 0x9e, 0x42, 0x37, 0x2d, 0xef, 0x3a, 0x1b, 0xde, 0x6d, 0x0c, 0x0e, 0xcd, 0xb8,
	0xee, 0x5f, 0x16, 0xec, 0x15, 0xea, 0x3b, 0x7a, 0x20, 0xf4, 0xc4, 0x76, 0xfa, 0x91, 0xeb, 0xd4,
	0x2b, 0x56, 0xd5, 0x2b, 0x76, 0xe6, 0x95, 0x62, 0xa0, 0x9d, 0xdb, 0x02, 0xdd, 0xad, 0x06, 0x1a,
	0xc7, 0x3b, 0x39, 0xea, 0x7d, 0x36, 0x13, 0x3c, 0x4c, 0x74, 0x4f, 0x32, 0x69, 0x09, 0xc5, 0x84,
	0x50, 0xc8, 0x05, 0x8b, 0xe6, 0x6c, 0x1d, 0x4b, 0xe7, 0x99, 0xb4, 0x08, 0xa2, 0xd7, 0xd1, 0x7a,
	0x74, 0x21, 0x28, 0xaf, 0x6b, 0x31, 0x1f, 0x8f, 0x5e, 0x53, 0x3c, 0x76, 0x0b, 0xf1, 0xa8, 0xa4,
	0xe0, 0xde, 0xdd, 0x52, 0xf0, 0x5e, 0x5d, 0x0a, 0x92, 0xc7, 0xf0, 0xbf, 0xe2, 0x8b, 0x90, 0xda,
	0x97, 0xd4, 0xea, 0x06, 0x79, 0x04, 0x83, 0xc2, 0xc3, 0x90, 0x3c, 0x90, 0xe4, 0x0a, 0x8e, 0x9f,
	0xf5, 0x3a, 0x59, 0xa9, 0x32, 0x21, 0x13, 0xc7, 0xa1, 0x19, 0x70, 0x6a, 0x77, 0x8c, 0x81, 0xe9,
	0x7e, 0x07, 0xfd, 0x52, 0x23, 0xc6, 0x00, 0xcb, 0x42, 0xa0, 0x66, 0x50, 0xb9, 0x6e, 0x18, 0x2a,
	0xf3, 0x63, 0x9f, 0x5d, 0x1c, 0xfb, 0xb4, 0xfa, 0xb7, 0x16, 0xdc, 0xaf, 0x69, 0xcb, 0xe4, 0x0b,
	0x5d, 0xa7, 0x55, 0x7a, 0x3e, 0xbd, 0x4b, 0x2b, 0x2f, 0x62, 0x17, 0x3c, 0x58, 0xc7, 0xaa, 0x5a,
	0xa3, 0x32, 0xd9, 0x3b, 0xcc, 0x7f, 0xa9, 0x4c, 0x76, 0x90, 0xc2, 0x18, 0x6e, 0x55, 0xc7, 0x70,
	0x6b, 0x16, 0xf8, 0x7a, 0x62, 0x6b, 0x6c, 0x04, 0xb3, 0xc0, 0x47, 0xa6, 0x27, 0x96, 0x7a, 0x26,
	0x6b, 0x64, 0x7a, 0x62, 0x79, 0xf0, 0x8b, 0x01, 0xa4, 0x6a, 0x4e, 0xd1, 0x10, 0xa3, 0x6c, 0x48,
	0x1a, 0x10, 0xb3, 0x7e, 0xca, 0xb7, 0x1a, 0xff, 0xaf, 0xd8, 0x37, 0xcd, 0xe7, 0x4e, 0x69, 0x3e,
	0x9f, 0xb5, 0xe5, 0xff, 0xbc, 0x8f, 0xff, 0x0e, 0x00, 0x00, 0xff, 0xff, 0x71, 0xa9, 0x12, 0x88,
	0xff, 0x0d, 0x00, 0x00,
}
